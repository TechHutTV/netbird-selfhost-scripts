#!/bin/bash

# =============================================================================
# NetBird NGINX Reverse Proxy Setup Script
# =============================================================================
# This script helps you configure NGINX as a reverse proxy for NetBird.
# It supports both existing NGINX installations and new deployments with
# automatic SSL certificate generation via Certbot.
# =============================================================================

set -e

# -----------------------------------------------------------------------------
# Color Configuration
# -----------------------------------------------------------------------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

print_banner() {
    echo -e "${CYAN}"
    echo "============================================================================="
    echo "       ${BOLD}NetBird NGINX Reverse Proxy Setup${NC}${CYAN}"
    echo "       Configure NGINX for NetBird with SSL"
    echo "============================================================================="
    echo -e "${NC}"
}

print_section() {
    echo ""
    echo -e "${BLUE}-----------------------------------------------------------------------------${NC}"
    echo -e "${BOLD}${BLUE}  $1${NC}"
    echo -e "${BLUE}-----------------------------------------------------------------------------${NC}"
    echo ""
}

print_step() {
    echo -e "${GREEN}>>>${NC} $1"
}

print_info() {
    echo -e "${CYAN}[i]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

print_error() {
    echo -e "${RED}[x]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[+]${NC} $1"
}

prompt_yes_no() {
    local prompt="$1"
    local default="${2:-y}"
    local response

    if [[ "$default" == "y" ]]; then
        prompt_text="$prompt [Y/n]: "
    else
        prompt_text="$prompt [y/N]: "
    fi

    echo -en "${MAGENTA}?${NC} $prompt_text"
    read -r response

    response=${response:-$default}
    [[ "$response" =~ ^[Yy]$ ]]
}

prompt_input() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    local response

    if [[ -n "$default" ]]; then
        echo -en "${MAGENTA}?${NC} $prompt [${default}]: "
    else
        echo -en "${MAGENTA}?${NC} $prompt: "
    fi

    read -r response
    response=${response:-$default}

    eval "$var_name='$response'"
}

check_command() {
    if command -v "$1" &> /dev/null; then
        return 0
    else
        return 1
    fi
}

check_docker_compose() {
    if docker compose version &> /dev/null; then
        DOCKER_COMPOSE_CMD="docker compose"
        return 0
    elif command -v docker-compose &> /dev/null; then
        DOCKER_COMPOSE_CMD="docker-compose"
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Generate NGINX Configuration
# -----------------------------------------------------------------------------

generate_nginx_config() {
    local domain="$1"
    local ssl_cert_path="$2"
    local ssl_key_path="$3"
    local upstream_network="${4:-localhost}"

    cat << 'NGINX_CONFIG_EOF'
# =============================================================================
# NetBird NGINX Reverse Proxy Configuration
# =============================================================================
# Generated by NetBird setup script
#
# IMPORTANT: This configuration requires:
#   - NGINX compiled with ngx_http_v2_module (for gRPC)
#   - NGINX compiled with ngx_stream_module (for UDP relay - optional)
# =============================================================================

# HTTP to HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name NETBIRD_DOMAIN;

    # Let's Encrypt challenge location
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://$server_name$request_uri;
    }
}

# Main HTTPS server
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name NETBIRD_DOMAIN;

    # SSL Configuration
    ssl_certificate SSL_CERT_PATH;
    ssl_certificate_key SSL_KEY_PATH;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS (optional but recommended)
    add_header Strict-Transport-Security "max-age=63072000" always;

    # Logging
    access_log /var/log/nginx/netbird_access.log;
    error_log /var/log/nginx/netbird_error.log;

    # -------------------------------------------------------------------------
    # Dashboard - Main web interface
    # -------------------------------------------------------------------------
    location / {
        proxy_pass http://UPSTREAM_NETWORK:80;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # -------------------------------------------------------------------------
    # Management API - HTTP endpoints
    # -------------------------------------------------------------------------
    location /api {
        proxy_pass http://UPSTREAM_NETWORK:80;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Increased timeouts for API calls
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # -------------------------------------------------------------------------
    # Management gRPC - Used by NetBird clients
    # -------------------------------------------------------------------------
    location /management.ManagementService/ {
        grpc_pass grpc://UPSTREAM_NETWORK:80;
        grpc_set_header Host $host;
        grpc_set_header X-Real-IP $remote_addr;
        grpc_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # gRPC specific settings
        grpc_read_timeout 3600s;
        grpc_send_timeout 3600s;

        # Required for streaming
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # -------------------------------------------------------------------------
    # Management WebSocket Proxy - For browser clients
    # -------------------------------------------------------------------------
    location /ws-proxy/management {
        proxy_pass http://UPSTREAM_NETWORK:80;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # -------------------------------------------------------------------------
    # Signal gRPC - Peer connection negotiation
    # -------------------------------------------------------------------------
    location /signalexchange.SignalExchange/ {
        grpc_pass grpc://UPSTREAM_NETWORK:80;
        grpc_set_header Host $host;
        grpc_set_header X-Real-IP $remote_addr;
        grpc_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # gRPC specific settings
        grpc_read_timeout 3600s;
        grpc_send_timeout 3600s;

        # Required for streaming
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # -------------------------------------------------------------------------
    # Signal WebSocket Proxy - For browser clients
    # -------------------------------------------------------------------------
    location /ws-proxy/signal {
        proxy_pass http://UPSTREAM_NETWORK:80;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # -------------------------------------------------------------------------
    # Relay WebSocket - Fallback relay for peers
    # -------------------------------------------------------------------------
    location /relay {
        proxy_pass http://UPSTREAM_NETWORK:33080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }
}

# =============================================================================
# OPTIONAL: UDP Stream for QUIC Relay (requires ngx_stream_module)
# =============================================================================
# Uncomment this section if you want to proxy QUIC traffic through NGINX.
# This requires NGINX to be compiled with --with-stream
#
# Add this to your nginx.conf (outside the http block):
#
# stream {
#     upstream relay_quic {
#         server UPSTREAM_NETWORK:33080;
#     }
#
#     server {
#         listen 33080 udp;
#         proxy_pass relay_quic;
#         proxy_timeout 3600s;
#     }
# }
# =============================================================================
NGINX_CONFIG_EOF
}

generate_nginx_config_with_substitutions() {
    local domain="$1"
    local ssl_cert_path="$2"
    local ssl_key_path="$3"
    local upstream_network="$4"

    generate_nginx_config | \
        sed "s|NETBIRD_DOMAIN|${domain}|g" | \
        sed "s|SSL_CERT_PATH|${ssl_cert_path}|g" | \
        sed "s|SSL_KEY_PATH|${ssl_key_path}|g" | \
        sed "s|UPSTREAM_NETWORK|${upstream_network}|g"
}

# -----------------------------------------------------------------------------
# Output Configuration for Existing NGINX
# -----------------------------------------------------------------------------

output_existing_nginx_config() {
    print_section "NGINX Configuration for Existing Installation"

    prompt_input "Enter your NetBird domain" "" "NETBIRD_DOMAIN"

    echo ""
    print_info "Where are your NetBird services running?"
    print_info "  - If on the same host: use 'localhost' or '127.0.0.1'"
    print_info "  - If in Docker: use the container name (e.g., 'dashboard', 'signal', 'management')"
    print_info "  - If on another host: use the IP address or hostname"
    echo ""

    prompt_input "Enter the upstream host/network for dashboard" "dashboard" "UPSTREAM_DASHBOARD"
    prompt_input "Enter the upstream host/network for signal" "signal" "UPSTREAM_SIGNAL"
    prompt_input "Enter the upstream host/network for management" "management" "UPSTREAM_MANAGEMENT"
    prompt_input "Enter the upstream host/network for relay" "relay" "UPSTREAM_RELAY"

    echo ""
    print_info "SSL Certificate paths (adjust these to match your setup):"
    prompt_input "Enter SSL certificate path" "/etc/letsencrypt/live/${NETBIRD_DOMAIN}/fullchain.pem" "SSL_CERT_PATH"
    prompt_input "Enter SSL private key path" "/etc/letsencrypt/live/${NETBIRD_DOMAIN}/privkey.pem" "SSL_KEY_PATH"

    echo ""
    echo ""
    print_section "NGINX Configuration - Copy and paste this into your nginx config"
    echo ""
    echo -e "${YELLOW}=============================================================================${NC}"
    echo -e "${YELLOW}COPY EVERYTHING BELOW THIS LINE${NC}"
    echo -e "${YELLOW}=============================================================================${NC}"
    echo ""

    # Generate customized config
    cat << EOF
# =============================================================================
# NetBird NGINX Reverse Proxy Configuration
# =============================================================================
# Generated by NetBird setup script for: ${NETBIRD_DOMAIN}
#
# IMPORTANT: This configuration requires:
#   - NGINX compiled with ngx_http_v2_module (for gRPC)
#   - NGINX compiled with ngx_stream_module (for UDP relay - optional)
#
# Save this file to: /etc/nginx/sites-available/netbird.conf
# Then run: sudo ln -s /etc/nginx/sites-available/netbird.conf /etc/nginx/sites-enabled/
# And reload: sudo nginx -t && sudo systemctl reload nginx
# =============================================================================

# HTTP to HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name ${NETBIRD_DOMAIN};

    # Let's Encrypt challenge location
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

# Main HTTPS server
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name ${NETBIRD_DOMAIN};

    # SSL Configuration
    ssl_certificate ${SSL_CERT_PATH};
    ssl_certificate_key ${SSL_KEY_PATH};
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS (optional but recommended)
    add_header Strict-Transport-Security "max-age=63072000" always;

    # Logging
    access_log /var/log/nginx/netbird_access.log;
    error_log /var/log/nginx/netbird_error.log;

    # -------------------------------------------------------------------------
    # Dashboard - Main web interface
    # -------------------------------------------------------------------------
    location / {
        proxy_pass http://${UPSTREAM_DASHBOARD}:80;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    # -------------------------------------------------------------------------
    # Management API - HTTP endpoints
    # -------------------------------------------------------------------------
    location /api {
        proxy_pass http://${UPSTREAM_MANAGEMENT}:80;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Increased timeouts for API calls
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # -------------------------------------------------------------------------
    # Management gRPC - Used by NetBird clients
    # -------------------------------------------------------------------------
    location /management.ManagementService/ {
        grpc_pass grpc://${UPSTREAM_MANAGEMENT}:80;
        grpc_set_header Host \$host;
        grpc_set_header X-Real-IP \$remote_addr;
        grpc_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;

        # gRPC specific settings
        grpc_read_timeout 3600s;
        grpc_send_timeout 3600s;

        # Required for streaming
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # -------------------------------------------------------------------------
    # Management WebSocket Proxy - For browser clients
    # -------------------------------------------------------------------------
    location /ws-proxy/management {
        proxy_pass http://${UPSTREAM_MANAGEMENT}:80;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # -------------------------------------------------------------------------
    # Signal gRPC - Peer connection negotiation
    # -------------------------------------------------------------------------
    location /signalexchange.SignalExchange/ {
        grpc_pass grpc://${UPSTREAM_SIGNAL}:80;
        grpc_set_header Host \$host;
        grpc_set_header X-Real-IP \$remote_addr;
        grpc_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;

        # gRPC specific settings
        grpc_read_timeout 3600s;
        grpc_send_timeout 3600s;

        # Required for streaming
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # -------------------------------------------------------------------------
    # Signal WebSocket Proxy - For browser clients
    # -------------------------------------------------------------------------
    location /ws-proxy/signal {
        proxy_pass http://${UPSTREAM_SIGNAL}:80;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # -------------------------------------------------------------------------
    # Relay WebSocket - Fallback relay for peers
    # -------------------------------------------------------------------------
    location /relay {
        proxy_pass http://${UPSTREAM_RELAY}:33080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }
}
EOF

    echo ""
    echo -e "${YELLOW}=============================================================================${NC}"
    echo -e "${YELLOW}COPY EVERYTHING ABOVE THIS LINE${NC}"
    echo -e "${YELLOW}=============================================================================${NC}"
    echo ""

    print_section "Next Steps"

    echo "1. Save the configuration above to a file:"
    echo "   sudo nano /etc/nginx/sites-available/netbird.conf"
    echo ""
    echo "2. Enable the site:"
    echo "   sudo ln -s /etc/nginx/sites-available/netbird.conf /etc/nginx/sites-enabled/"
    echo ""
    echo "3. If you don't have SSL certificates yet, obtain them with Certbot:"
    echo "   sudo apt install certbot python3-certbot-nginx"
    echo "   sudo certbot certonly --nginx -d ${NETBIRD_DOMAIN}"
    echo ""
    echo "4. Test and reload NGINX:"
    echo "   sudo nginx -t && sudo systemctl reload nginx"
    echo ""

    print_warning "Make sure your NetBird services are running and accessible at the configured upstream addresses."
    print_warning "The QUIC relay (UDP port 33080) must be exposed directly - NGINX cannot proxy UDP in the http block."
}

# -----------------------------------------------------------------------------
# Setup New NGINX with Docker and Certbot
# -----------------------------------------------------------------------------

setup_new_nginx() {
    print_section "New NGINX Setup with Docker and Certbot"

    # Check prerequisites
    print_step "Checking prerequisites..."

    if ! check_command "docker"; then
        print_error "Docker is not installed. Please install Docker first."
        exit 1
    fi
    print_success "Docker is installed"

    if ! check_docker_compose; then
        print_error "Docker Compose is not installed. Please install Docker Compose first."
        exit 1
    fi
    print_success "Docker Compose is available"

    echo ""

    # Collect configuration
    prompt_input "Enter your NetBird domain" "" "NETBIRD_DOMAIN"
    prompt_input "Enter your email for Let's Encrypt notifications" "" "LETSENCRYPT_EMAIL"

    echo ""
    print_info "Docker network configuration:"
    print_info "  Your NetBird services should be on a shared Docker network."
    prompt_input "Enter the Docker network name where NetBird services run" "netbird" "DOCKER_NETWORK"

    # Check if network exists
    if docker network ls --format '{{.Name}}' | grep -q "^${DOCKER_NETWORK}$"; then
        print_success "Docker network '${DOCKER_NETWORK}' exists"
    else
        print_warning "Docker network '${DOCKER_NETWORK}' does not exist yet"
        if prompt_yes_no "Create the network now?" "y"; then
            docker network create "${DOCKER_NETWORK}"
            print_success "Created Docker network '${DOCKER_NETWORK}'"
        fi
    fi

    echo ""
    prompt_input "Enter the dashboard container/service name" "dashboard" "UPSTREAM_DASHBOARD"
    prompt_input "Enter the signal container/service name" "signal" "UPSTREAM_SIGNAL"
    prompt_input "Enter the management container/service name" "management" "UPSTREAM_MANAGEMENT"
    prompt_input "Enter the relay container/service name" "relay" "UPSTREAM_RELAY"

    # Create directory structure
    SETUP_DIR="$(pwd)/nginx-netbird"
    print_step "Creating setup directory: ${SETUP_DIR}"
    mkdir -p "${SETUP_DIR}/nginx/conf.d"
    mkdir -p "${SETUP_DIR}/certbot/conf"
    mkdir -p "${SETUP_DIR}/certbot/www"

    # Generate nginx configuration
    print_step "Generating NGINX configuration..."

    cat > "${SETUP_DIR}/nginx/conf.d/netbird.conf" << EOF
# =============================================================================
# NetBird NGINX Reverse Proxy Configuration
# =============================================================================
# Generated by NetBird setup script for: ${NETBIRD_DOMAIN}
# =============================================================================

# HTTP server for Let's Encrypt challenges and redirect
server {
    listen 80;
    listen [::]:80;
    server_name ${NETBIRD_DOMAIN};

    # Let's Encrypt challenge location
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

# Main HTTPS server
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name ${NETBIRD_DOMAIN};

    # SSL Configuration - Updated by Certbot
    ssl_certificate /etc/letsencrypt/live/${NETBIRD_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${NETBIRD_DOMAIN}/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;

    # Dashboard - Main web interface
    location / {
        proxy_pass http://${UPSTREAM_DASHBOARD}:80;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    # Management API
    location /api {
        proxy_pass http://${UPSTREAM_MANAGEMENT}:80;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Management gRPC
    location /management.ManagementService/ {
        grpc_pass grpc://${UPSTREAM_MANAGEMENT}:80;
        grpc_set_header Host \$host;
        grpc_set_header X-Real-IP \$remote_addr;
        grpc_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        grpc_read_timeout 3600s;
        grpc_send_timeout 3600s;
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # Management WebSocket
    location /ws-proxy/management {
        proxy_pass http://${UPSTREAM_MANAGEMENT}:80;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # Signal gRPC
    location /signalexchange.SignalExchange/ {
        grpc_pass grpc://${UPSTREAM_SIGNAL}:80;
        grpc_set_header Host \$host;
        grpc_set_header X-Real-IP \$remote_addr;
        grpc_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        grpc_read_timeout 3600s;
        grpc_send_timeout 3600s;
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # Signal WebSocket
    location /ws-proxy/signal {
        proxy_pass http://${UPSTREAM_SIGNAL}:80;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # Relay WebSocket
    location /relay {
        proxy_pass http://${UPSTREAM_RELAY}:33080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }
}
EOF
    print_success "NGINX configuration created"

    # Create initial nginx config for certificate generation
    print_step "Creating initial NGINX config for certificate generation..."
    cat > "${SETUP_DIR}/nginx/conf.d/default.conf" << EOF
# Temporary config for Let's Encrypt certificate generation
server {
    listen 80;
    listen [::]:80;
    server_name ${NETBIRD_DOMAIN};

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 200 'NetBird NGINX is running. Waiting for SSL certificate...';
        add_header Content-Type text/plain;
    }
}
EOF

    # Generate docker-compose.yml
    print_step "Generating docker-compose.yml..."

    cat > "${SETUP_DIR}/docker-compose.yml" << EOF
# =============================================================================
# NetBird NGINX Reverse Proxy with Certbot
# =============================================================================
# Generated by NetBird setup script
# =============================================================================

services:
  nginx:
    image: nginx:alpine
    container_name: netbird-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./certbot/conf:/etc/letsencrypt:ro
      - ./certbot/www:/var/www/certbot:ro
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      - certbot
    command: "/bin/sh -c 'while :; do sleep 6h & wait \$\${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  certbot:
    image: certbot/certbot
    container_name: netbird-certbot
    restart: unless-stopped
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait \$\${!}; done;'"
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  ${DOCKER_NETWORK}:
    external: true
EOF
    print_success "docker-compose.yml created"

    # Generate helper scripts
    print_step "Generating helper scripts..."

    # Initial certificate script
    cat > "${SETUP_DIR}/init-letsencrypt.sh" << 'INIT_SCRIPT'
#!/bin/bash

# =============================================================================
# Let's Encrypt Certificate Initialization Script
# =============================================================================

set -e

DOMAIN="NETBIRD_DOMAIN_PLACEHOLDER"
EMAIL="LETSENCRYPT_EMAIL_PLACEHOLDER"
STAGING="${STAGING:-0}"  # Set to 1 for testing

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}>>> Starting Let's Encrypt certificate initialization${NC}"

# Check if certificate already exists
if [ -d "./certbot/conf/live/${DOMAIN}" ]; then
    echo -e "${YELLOW}Certificate already exists for ${DOMAIN}${NC}"
    read -p "Do you want to replace it? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Keeping existing certificate."
        exit 0
    fi
fi

# Create required directories
mkdir -p ./certbot/conf ./certbot/www

# Determine staging flag
if [ "$STAGING" = "1" ]; then
    STAGING_ARG="--staging"
    echo -e "${YELLOW}>>> Using Let's Encrypt staging environment (for testing)${NC}"
else
    STAGING_ARG=""
fi

# Start nginx for the challenge
echo -e "${GREEN}>>> Starting NGINX for ACME challenge...${NC}"
docker compose up -d nginx

# Wait for nginx to be ready
echo "Waiting for NGINX to start..."
sleep 5

# Request certificate
echo -e "${GREEN}>>> Requesting Let's Encrypt certificate for ${DOMAIN}...${NC}"
docker compose run --rm certbot certonly \
    --webroot \
    --webroot-path=/var/www/certbot \
    --email "${EMAIL}" \
    --agree-tos \
    --no-eff-email \
    ${STAGING_ARG} \
    -d "${DOMAIN}"

# Check if certificate was obtained
if [ -d "./certbot/conf/live/${DOMAIN}" ]; then
    echo -e "${GREEN}>>> Certificate obtained successfully!${NC}"

    # Switch to the full config
    echo -e "${GREEN}>>> Switching to full NGINX configuration...${NC}"
    rm -f ./nginx/conf.d/default.conf

    # Reload nginx
    docker compose exec nginx nginx -s reload

    echo ""
    echo -e "${GREEN}=============================================================================${NC}"
    echo -e "${GREEN}SSL Certificate successfully installed!${NC}"
    echo -e "${GREEN}=============================================================================${NC}"
    echo ""
    echo "Your NetBird instance should now be accessible at:"
    echo "  https://${DOMAIN}"
    echo ""
    echo "Certificate auto-renewal is configured via the certbot container."
    echo ""
else
    echo -e "${RED}>>> Failed to obtain certificate${NC}"
    echo "Please check the logs: docker compose logs certbot"
    exit 1
fi
INIT_SCRIPT

    # Replace placeholders
    sed -i "s|NETBIRD_DOMAIN_PLACEHOLDER|${NETBIRD_DOMAIN}|g" "${SETUP_DIR}/init-letsencrypt.sh"
    sed -i "s|LETSENCRYPT_EMAIL_PLACEHOLDER|${LETSENCRYPT_EMAIL}|g" "${SETUP_DIR}/init-letsencrypt.sh"
    chmod +x "${SETUP_DIR}/init-letsencrypt.sh"

    # Create renewal check script
    cat > "${SETUP_DIR}/renew-certificates.sh" << 'RENEW_SCRIPT'
#!/bin/bash
# Manual certificate renewal script
docker compose run --rm certbot renew
docker compose exec nginx nginx -s reload
RENEW_SCRIPT
    chmod +x "${SETUP_DIR}/renew-certificates.sh"

    print_success "Helper scripts created"

    # Summary and next steps
    print_section "Setup Complete"

    echo "Files have been created in: ${SETUP_DIR}"
    echo ""
    echo "Directory structure:"
    echo "  ${SETUP_DIR}/"
    echo "  ├── docker-compose.yml"
    echo "  ├── init-letsencrypt.sh"
    echo "  ├── renew-certificates.sh"
    echo "  ├── nginx/"
    echo "  │   └── conf.d/"
    echo "  │       ├── default.conf (temporary, for cert generation)"
    echo "  │       └── netbird.conf (full config)"
    echo "  └── certbot/"
    echo "      ├── conf/  (certificates will be stored here)"
    echo "      └── www/   (ACME challenge files)"
    echo ""

    print_section "Next Steps"

    echo "1. Make sure your DNS is pointing to this server:"
    echo "   ${NETBIRD_DOMAIN} -> $(curl -s ifconfig.me 2>/dev/null || echo 'YOUR_SERVER_IP')"
    echo ""
    echo "2. Make sure ports 80 and 443 are open in your firewall"
    echo ""
    echo "3. Navigate to the setup directory:"
    echo "   cd ${SETUP_DIR}"
    echo ""
    echo "4. Initialize Let's Encrypt certificates:"
    echo "   ./init-letsencrypt.sh"
    echo ""
    echo "   For testing, use: STAGING=1 ./init-letsencrypt.sh"
    echo ""
    echo "5. Start the services (if not already running):"
    echo "   docker compose up -d"
    echo ""

    if prompt_yes_no "Would you like to initialize certificates now?" "y"; then
        cd "${SETUP_DIR}"
        ./init-letsencrypt.sh
    else
        print_info "You can initialize certificates later by running:"
        echo "   cd ${SETUP_DIR} && ./init-letsencrypt.sh"
    fi
}

# -----------------------------------------------------------------------------
# Show Help
# -----------------------------------------------------------------------------

show_help() {
    echo "NetBird NGINX Reverse Proxy Setup Script"
    echo ""
    echo "Usage: ./setup.sh [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --help, -h        Show this help message"
    echo "  --existing        Configure for existing NGINX installation"
    echo "  --new             Setup new NGINX with Docker and Certbot"
    echo ""
    echo "Without options, the script will ask which mode you want."
    echo ""
    echo "Examples:"
    echo "  ./setup.sh                  Interactive mode"
    echo "  ./setup.sh --existing       Output config for existing NGINX"
    echo "  ./setup.sh --new            Setup new NGINX with Docker"
    echo ""
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Parse arguments
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --existing)
            print_banner
            output_existing_nginx_config
            exit 0
            ;;
        --new)
            print_banner
            setup_new_nginx
            exit 0
            ;;
        "")
            # Interactive mode
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac

    print_banner

    echo "This script helps you configure NGINX as a reverse proxy for NetBird."
    echo ""
    echo "Choose your setup type:"
    echo ""
    echo "  1) Existing NGINX - Output configuration to copy/paste"
    echo "     Use this if you already have NGINX running and want to add NetBird"
    echo ""
    echo "  2) New NGINX - Deploy with Docker and automatic SSL"
    echo "     Use this to set up a fresh NGINX with Certbot for SSL certificates"
    echo ""

    prompt_input "Select option (1 or 2)" "1" "SETUP_OPTION"

    case "$SETUP_OPTION" in
        1|existing)
            output_existing_nginx_config
            ;;
        2|new)
            setup_new_nginx
            ;;
        *)
            print_error "Invalid option: $SETUP_OPTION"
            exit 1
            ;;
    esac
}

main "$@"
